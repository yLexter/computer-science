# Analysis of Sorting Algorithms

- Group: Mateus Vitor, Joana Dark and João Gabriel

In this project, we implemented and analyzed the following sorting algorithms in Python:

1. **Bubble Sort**
 - Disordered Values: High execution time on larger samples, significant memory usage.
 - Values ​​Sorted Increasingly: Better performance, but still slow in larger samples.
 - Values ​​Sorted Descendingly: Performance similar to disordered values.
 - Constant Values: Better Performance.
 - Partially Ordered Values ​​(Disordered Final): Reasonable execution time.
 - Partially Ordered Values ​​(Disordered Start): Reasonable execution time.

2. **Selection Sort**
 - Disordered Values: High execution time on larger samples, moderate memory usage.
 - Increasingly Ordered Values: Performance similar to disordered values.
 - Values ​​Sorted Descending: Better performance, but still slow in larger samples.
 - Constant Values: Reasonable performance.
 - Partially Ordered Values ​​(Disordered Final): Reasonable execution time.
 - Partially Ordered Values ​​(Disordered Start): Reasonable execution time.

3. **Insertion Sort**
 - Disordered Values: Reasonable execution time, moderate memory usage.
 - Values ​​Sorted Increasingly: Better performance, fast even in larger samples.
 - Values ​​Sorted Descendingly: Performance similar to unordered values.
 - Constant Values: Reasonable performance.
 - Partially Ordered Values ​​(Disordered Final): Reasonable execution time.
 - Partially Ordered Values ​​(Disordered Start): Reasonable execution time.

4. **Merge Sort**
 - Disordered Values: Good performance, moderate memory usage.
 - Values ​​Sorted Increasingly: Reasonable execution time.
 - Values ​​Ordered Descendingly: Reasonable execution time.
 - Constant Values: Good performance.
 - Partially Ordered Values ​​(Disordered Final): Good performance.
 - Partially Ordered Values ​​(Disordered Start): Good performance.

5. **Quick Sort**
 - Disordered Values: Good performance on larger samples, moderate memory usage.
 - Values ​​Sorted Increasingly: Reasonable execution time.
 - Values ​​Ordered Descendingly: Reasonable execution time.
 - Constant Values: Good performance.
 - Partially Ordered Values ​​(Disordered Final): Good performance.
 - Partially Ordered Values ​​(Disordered Start): Good performance.

6. **Counting Sort**
 - Unordered Values: Excellent performance on larger samples, minimal memory usage.
 - Values ​​Sorted Increasingly: Excellent performance.
 - Values ​​Ordered Descendingly: Excellent performance.
 - Constant Values: Excellent performance.
 - Partially Ordered Values ​​(Disordered Final): Excellent performance.
 - Partially Ordered Values ​​(Disordered Start): Excellent performance.

## Conclusion

The analysis results indicate that the Counting Sort algorithm is the most efficient in terms of execution time and memory usage in most input scenarios. However, the choice of sorting algorithm depends on the specific characteristics of the data and the performance requirements of your application.