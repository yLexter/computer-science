# -*- coding: utf-8 -*-
"""Heap e Hash.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dAYr97zcgMDp16PZ6Z1t_UZTK_yxuWjd
"""

import os.path
import random
import time
import copy
import matplotlib.pyplot as plt
import math
import numpy as np
import json
import shutil
import zipfile

class MergeSort:
    nome = "Merge Sort"

    def merge(self, A, aux, esquerda, meio, direita):
      for k in range(esquerda, direita + 1):
          aux[k] = A[k]
      i = esquerda
      j = meio + 1

      for k in range(esquerda, direita + 1):
          if i > meio:
              A[k] = aux[j]
              j += 1
          elif j > direita:
              A[k] = aux[i]
              i += 1
          elif aux[j] < aux[i]:
              A[k] = aux[j]
              j += 1
          else:
              A[k] = aux[i]
              i += 1

    def run(self, arr):
       aux = [0] * len(arr)
       self.mergesort(arr, aux, 0, len(arr) - 1)

    def mergesort(self, arr, aux, esquerda, direita):
        if direita <= esquerda:
            return

        meio = (esquerda + direita) // 2
        self.mergesort(arr, aux, esquerda, meio)
        self.mergesort(arr, aux, meio + 1, direita)
        self.merge(arr, aux, esquerda, meio, direita)


class CoutingSort:
    nome = "Couting Sort"

    def run(self, arr):
        max_val = max(arr)
        count = [0] * (max_val + 1)

        for num in arr:
            count[num] += 1

        sorted_arr = []

        for i in range(max_val + 1):
            sorted_arr.extend([i] * count[i])

        return sorted_arr

class HeapSort:
    nome = "Heap Sort"

    def heapify(self, arr, n, i):
          maior = i
          esquerda = 2 * i + 1
          direita = 2 * i + 2

          if esquerda < n and arr[esquerda] > arr[maior]:
              maior = esquerda

          if direita < n and arr[direita] > arr[maior]:
              maior = direita

          if maior != i:
              arr[i], arr[maior] = arr[maior], arr[i]
              self.heapify(arr, n, maior)

    def construir_heap(self, arr):
        n = len(arr)

        for i in range(n // 2 - 1, -1, -1):
            self.heapify(arr, n, i)

    def run(self, arr):
        if len(arr) <= 1:
            return arr

        arr = arr.copy()
        n = len(arr)

        self.construir_heap(arr)

        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]
            self.heapify(arr, i, 0)

        return arr

class Vetor:

    @staticmethod
    def obterPorcentagem(size):
        PORCENTAGEM = 90
        return  math.ceil(size * (PORCENTAGEM / 100))

    @staticmethod
    def conversorLista(lista):
        return np.array(lista, dtype=np.int64)

    @staticmethod
    def gerarVetorOrdemCrescente(size):
        lista = Vetor.conversorLista(list(range(size)))
        n = len(lista) - 1
        k = 0

        while k < n:
            numeroAleatorio = random.randint(1, n - 2)
            lista[numeroAleatorio - 1] = lista[numeroAleatorio]
            k += int(size * 0.15)

        return Vetor.conversorLista(lista)

    @staticmethod
    def gerarVetoOrdemDecrescente(size):
        lista = Vetor.gerarVetorOrdemCrescente(size)
        lista = lista[::-1]

        return lista

    @staticmethod
    def gerarVetorOrdemConstante(size):
        lista = [0] * size
        return Vetor.conversorLista(lista)

    @staticmethod
    def gerarVetorCrescenteComFinalAleatorio(size):
        totalPorcentagem = Vetor.obterPorcentagem(size)
        lista1 = Vetor.gerarVetorOrdemCrescente(totalPorcentagem)
        lista2 = Vetor.gerarVetorOrdemAleatoria(size - totalPorcentagem, size)

        return np.concatenate((lista1, lista2))

    @staticmethod
    def gerarVetorCrescenteComComecoAleatorio(size):
        totalPorcentagem = Vetor.obterPorcentagem(size)
        lista1 = Vetor.gerarVetorOrdemAleatoria(size - totalPorcentagem, size)
        lista2 = Vetor.gerarVetorOrdemCrescente(totalPorcentagem)

        return np.concatenate((lista1, lista2))

    @staticmethod
    def gerarVetorOrdemAleatoria(size, intervalo = 0):
        intervalo = intervalo if intervalo != 0 else size
        lista = [random.randint(0, intervalo) for _ in range(size)]
        return Vetor.conversorLista(lista)

class AlgoritmoBenchmark:
    TAMANHO_VETORES = [100_000, 500_000, 1_000_000,  2_000_000, 3_000_000]
    ALGORITMOS = [
        HeapSort(),
        MergeSort(),
        CoutingSort()
    ]

    dirDados = "dados"
    dirGraficos = "graficos"

    TIPOS_VETORES = [
        {
            "nome": "Ordem Crescente",
            "funcao": Vetor.gerarVetorOrdemCrescente
        },
        {
            "nome": "Ordem Decrescente",
            "funcao": Vetor.gerarVetoOrdemDecrescente
        },
        {
            "nome": "Ordem Aleatoria",
            "funcao": Vetor.gerarVetorOrdemAleatoria
        },
        {
            "nome": "Ordem Constante",
            "funcao": Vetor.gerarVetorOrdemConstante
        },
        {
            "nome": "Ordem Crescente com Começo Aleatorio",
            "funcao": Vetor.gerarVetorCrescenteComComecoAleatorio
        },
        {
            "nome": "Ordem Crescente com Final Aleatorio",
            "funcao": Vetor.gerarVetorCrescenteComFinalAleatorio
        }
    ]

    VETORES = None

    def setarVetores(self):
        vetores = {}

        for tipo in self.TIPOS_VETORES:
            vetores[tipo["nome"]] = [tipo["funcao"](tam) for tam in self.TAMANHO_VETORES]

        self.VETORES = vetores

    def obterDadosDeVetores(self):
        dadosFinal = []
        dicVetores = self.VETORES

        for tipo, vetores in dicVetores.items():

            dadosVetores = { "tipo": tipo, "dados": [] }

            for algoritmo in self.ALGORITMOS:

                dadosAlgoritmo = { "algoritmo": algoritmo.nome, "benchmarks": [] }

                for vetor in vetores:
                    copiaVetor = copy.copy(vetor)
                    benchmark = self.benchmark(algoritmo, copiaVetor)
                    dadosAlgoritmo["benchmarks"].append(benchmark)
                    print(f"Ordenção {tipo} - {algoritmo.nome} - Tamanho: {len(vetor)} finalizada com sucesso")

                dadosVetores["dados"].append(dadosAlgoritmo)

            dadosFinal.append(dadosVetores)

        return dadosFinal

    def benchmark(self, algoritmo, vetor):
        inicio = time.time()
        algoritmo.run(vetor)
        final = time.time()
        duracao = final - inicio

        return {
            "tempo": round(duracao, 5),
            "tamanho": len(vetor)
        }

    def salvarGraficos(self, dadosVetores):

        for dadoVetor in dadosVetores:
            (_, tipo_ordenacao), (_, dadosAlgoritmos) = dadoVetor.items()

            plt.figure(figsize=(10, 5))

            for dadosAlgoritmo in dadosAlgoritmos:
                (__, nome), (__, benchmarks) = dadosAlgoritmo.items()

                tamanhos = [benchmark["tamanho"] for benchmark in benchmarks]
                tempos_execucao = [benchmark["tempo"] for benchmark in benchmarks]

                plt.plot(tamanhos, tempos_execucao, marker='o', label=nome)

            plt.title(f'Tempo de Execução Com Vetor de {tipo_ordenacao}')
            plt.xlabel('Tamanho do Vetor')
            plt.ylabel('Tempo (segundos)')
            plt.legend()

            if not os.path.exists(self.dirGraficos):
               os.mkdir(self.dirGraficos)

            path = os.path.join(self.dirGraficos, f"Gráfico-{tipo_ordenacao}.png")
            plt.savefig(path)

    def obterDadosTabela(self, dados):
        dadosAlgoritmos = {}

        for j, coluna in enumerate(dados):
            posicaoAtual = j % len(self.ALGORITMOS)
            algoritmo = coluna["dados"][posicaoAtual]
            nomeAlgoritmo = algoritmo["algoritmo"]
            dadosAlgoritmos[nomeAlgoritmo] = { "benchmarks": [] }

            for i, linha in enumerate(dados):
                tipoVetor =  linha["tipo"]
                benchmarks = linha["dados"][posicaoAtual]["benchmarks"]

                dadosAlgoritmos[nomeAlgoritmo]["benchmarks"].append({
                    "tipo": tipoVetor,
                    "benchmark": benchmarks
                })

        return dadosAlgoritmos

    def salvarDados(self, dadosVetores):
        dadosTabela = self.obterDadosTabela(dadosVetores)

        if not os.path.exists(self.dirDados):
           os.mkdir(self.dirDados)

        with open("tabela.json", 'w') as arquivo:
             json.dump(dadosTabela, arquivo)

    def zip_folder(self, folder_path):
        with zipfile.ZipFile(f'{folder_path}.zip', 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(folder_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, folder_path)
                    zipf.write(file_path, arcname)

    def ziparPastas(self):
        self.zip_folder(self.dirDados)
        self.zip_folder(self.dirGraficos)


    def run(self):
        self.setarVetores()

        dadosVetores = self.obterDadosDeVetores()

        self.salvarGraficos(dadosVetores)
        self.salvarDados(dadosVetores)
        self.ziparPastas()

algoritmoBenchmark = AlgoritmoBenchmark()
algoritmoBenchmark.run()